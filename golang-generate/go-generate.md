现在有了go generate，可以用它来做新的事情。作为一个不同寻常的如何使用go generate的例子，有一个新的程序golang.org/x/tools仓库称为stringer。它可以自动为整数常量集合编写字符串方法。它不是发行版的一部分，但它很容易安装。



$ go get golang.org/x/tools/cmd/stringer

 



Stringer文档中有个示例，假设我们有一些包含一组定义不同类型的整形常数：



 



 



package painkiller



 



type Pill int



 



const \(



    Placebo Pill = iota



    Aspirin



    Ibuprofen



    Paracetamol



    Acetaminophen = Paracetamol



\)



 



为了调试，我们希望变量很够很好地打印自己，这意味着我们需要一个具有如下签名的方法。



 



func \(p Pill\) String\(\) string



 



手写很容易，也许是这样的：



func \(p Pill\) String\(\) string {



    switch p {



    case Placebo:



        return "Placebo"



    case Aspirin:



        return "Aspirin"



    case Ibuprofen:



        return "Ibuprofen"



    case Paracetamol: // == Acetaminophen



        return "Paracetamol"



    }



    return fmt.Sprintf\("Pill\(%d\)", p\)



}



 



当然还有其他的方法来写这个功能。我们可以使用一些Pill索引的字符串，或者map，或者其他一些技术。无论我们做什么，如果我们改变Pills集合，我们需要维护它来保证它是正确的。（Paracetamol的两个Name比其他的要棘手）。另外，采取哪种方法的问题取决于类型和值：有符号还是无符号，密集还是稀疏，基于零还是不基于零的等等。



 



Stringer程序负责处理所有这些细节。虽然它可以独立运行，但是它是由go generate驱动的要使用它，可以向源代码中添加生成注释，类型定义附近。



//go:generate stringer -type=Pill



 



此规则制定go generate 应运行stringer工具以生成Pill类型的String方法。输出会自动写入pill\_string.go（默认情况下，我们可以使用 -output标志来覆盖）



运行之后



$ go generate



$ cat pill\_string.go



// generated by stringer -type Pill pill.go; DO NOT EDIT



 



package pill



 



import "fmt"



 



const \_Pill\_name = "PlaceboAspirinIbuprofenParacetamol"



 



var \_Pill\_index = \[...\]uint8{0, 7, 14, 23, 34}



 



func \(i Pill\) String\(\) string {



    if i &lt; 0 \|\| i+1 &gt;= Pill\(len\(\_Pill\_index\)\) {



        return fmt.Sprintf\("Pill\(%d\)", i\)



    }



    return \_Pill\_name\[\_Pill\_index\[i\]:\_Pill\_index\[i+1\]\]



}



$



每次更改Pill或常量的定义时，我们需要做的就是运行go generate来更新String方法。当然，如果我们在同一个包中有多种类型设置了这种方式，单个命可以更新所有的String方法。



毫无疑问，生成的方法是丑的。但是，那是可以接受的，因为人类不需要做与它相关的工作，机器生成的代码通常是丑的。它努力做到高效率。所有的名称都在一个单一的字符串中，这样可以节省内存（即使有数十个也只有一个字符串头）。然后，一个数组，\_Pill\_index,通过一个简单高效的技术从值映射到名称。也请注意，\_Pill\_index是uint8的一个数组（不是一个切片），这是一个足够跨越值空间的最小整数。如果有更多的值，或者更少的，那么生产的\_Pill\_index类型可能会改变为uint16或者int8；无论什么都效果很好。



Stringer生成的Method使用的方法会根据常量集合的属性而变化。例如，如果常量是稀疏的，它可能会使用一个map。下面是一个基于常数集的常见例子，它代表了另外一种，



 



const \_Power\_name = "p0p1p2p3p4p5..."



 



var \_Power\_map = map\[Power\]string{



    1:    \_Power\_name\[0:2\],



    2:    \_Power\_name\[2:4\],



    4:    \_Power\_name\[4:6\],



    8:    \_Power\_name\[6:8\],



    16:   \_Power\_name\[8:10\],



    32:   \_Power\_name\[10:12\],



    ...,



}



 



func \(i Power\) String\(\) string {



    if str, ok := \_Power\_map\[i\]; ok {



        return str



    }



    return fmt.Sprintf\("Power\(%d\)", i\)



}



简而言之，自动生成的method可以做到比人类做地更好。



在go tree中已经安装了go generate的许多其他用途。包括在unicode包中生产Unicode表，为encoding/gob创建有效的编解码方法，在time包中创建时区数据等等。



请创造性的使用go generate，鼓励动手实践。



 



即使没有，使用新的stringer工具为您的整形常量编写String方法。让机器做这样的工作。

